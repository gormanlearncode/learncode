<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>helperfunctions.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Backdrop.html">Backdrop</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Backdrop.html#.create">create</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Backdrop.html#addBackdrop">addBackdrop</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Backdrop.html#addSprite">addSprite</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Backdrop.html#changeColor">changeColor</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Backdrop.html#clearGraphicsEffect">clearGraphicsEffect</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Backdrop.html#nextBackdrop">nextBackdrop</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Backdrop.html#setColor">setColor</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Backdrop.html#switchBackdropToIndex">switchBackdropToIndex</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Controls.html">Controls</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Controls.html#.repeat">repeat</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Controls.html#.wait">wait</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Sprite.html">Sprite</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sprite.html#.create">create</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sprite.html#getDiv">getDiv</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sprite.html#glideTo">glideTo</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sprite.html#move">move</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sprite.html#moveTo">moveTo</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sprite.html#setDirection">setDirection</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sprite.html#setX">setX</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sprite.html#setY">setY</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sprite.html#turnAnticlockwise">turnAnticlockwise</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sprite.html#turnClockwise">turnClockwise</a></span></li><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#animate">animate</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">helperfunctions.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Animates an object over a named period of time. For example, the below will move the circle from 20->320px over 100ms.
 * @example
 * animate(function(progress){ 
 *    circle.style.top = 20 + progress * 300 + 'px';
 * },1000).then( function(){
 *    console.log("done");
 * });
 * 
 * @param   {function} draw  A function that is called to animate your object, it contains a float, between 0-1, 
 *                     used in your code to set how far your animation should move as a ration of the total move
 *                     you want to make.
 * @param   {number} duration  How long should the animation last.
 * @param   {function} timing  an [optional] function that can manipulate the timing of the loop [default]=liniar.
 * @returns {Promise} a promise you can use "then" to know when it is complete. 
 */
function animate(draw, duration, timing) {

  return new Promise((resolve, reject) => {
    let start = performance.now();
    if (!timing) timing = function (timeFraction) { return timeFraction; }

    requestAnimationFrame(function animate(time) {
      // timeFraction goes from 0 to 1
      let timeFraction = (time - start) / duration;
      if (timeFraction > 1) timeFraction = 1;

      // calculate the current animation state
      let progress = timing(timeFraction)

      draw(progress); // draw it

      if (timeFraction &lt; 1) {
        requestAnimationFrame(animate);
      }
      else {
        resolve();
      }

    });
  });
}

/**
 * Sprite helps move a div object on the page. For example:
 * @example
 * const person = new Sprite("#personDiv");
 * person.turnClockWise(90);
 *
 */
class Sprite {
  /**
   * Create a Sprite object.
   * @param {object} htmldiv - The htmldiv object to move.
   */
  constructor(htmldiv) {
    if (htmldiv == null) {
      this.htmldiv = document.createElement("div");
      this.htmldiv.style.position = "relative";
    }
    else if (typeof htmldiv === "string") {
      this.htmldiv = document.querySelector(htmldiv);
    }
    else {
      this.htmldiv = htmldiv;
    }
    this.direction=90;

  }
  /**
  * create 
  * @param   {image}
  * @param   {height}
  * @param   {width}
  * @returns {Sprite} a new Sprite.
  */
  static create({ image, height, width }) {
    let sprite = new Sprite();
    sprite.htmldiv.style.backgroundImage = `url('${image}')`;
    sprite.htmldiv.style.backgroundSize = "contain";
    sprite.htmldiv.style.height = `${height}px`;
    sprite.htmldiv.style.width = `${width}px`;
    return sprite;
  }
  /**
   * turnClockWise degrees  
   * @param   {number}
   */
  turnClockwise(degrees) {
    this.direction=this.direction+degrees;
    this.htmldiv.style.transform = 'rotate(' + ((this.direction-90)) + 'deg)';
  }

  /**
   * setDirection 90 degrees equals a vertical images moving to the right.
   * @param   {number}
   */
  setDirection(degrees) {
    this.direction=degrees;
    this.htmldiv.style.transform = 'rotate(' + ((this.direction-90)) + 'deg)';
  }
  /**
   * turnAnticlockwise
   * @param   {number} degrees  
   */
  turnAnticlockwise(degrees) {
    this.direction=this.direction-degrees;
    this.htmldiv.style.transform = 'rotate(' + ((this.direction-90)) + 'deg)';
  }
  /**
   * move
   * @param   {number} steps  
   */
  move(steps) {
    const _left = parseInt(this.htmldiv.style.left || "0px");
    const _top = parseInt(this.htmldiv.style.top || "0px");
    let pixelX=Math.round(steps*Math.sin(this.direction*Math.PI/180),3);
    let pixelY=Math.round(-steps*Math.cos(this.direction*Math.PI/180),3);
    console.log("this.direction:"+this.direction);
    console.log("pixelX:"+pixelX+"   pixelY:"+pixelY);
    this.htmldiv.style.left = '' + (_left + pixelX) + 'px'; 
    this.htmldiv.style.top = '' + (_top + pixelY) + 'px';
  }

  /**
   * moveTo a specific position
   * @param   {number} pixelX  
   * @param   {number} pixelY  
   */
  moveTo(pixelX, pixelY) {
    const _left = parseInt(this.htmldiv.style.left || "0px") || 0;
    const _top = parseInt(this.htmldiv.style.top || "0px") || 0;
    this.htmldiv.style.left = "" + pixelX + "px"; 
    this.htmldiv.style.top = "" + pixelY + "px";
  }

  /**
   * glideTo a specific position over time.
   * @param   {number} pixelX  
   * @param   {number} pixelY  
   * @param   {number} milliseconds  
   * @returns {Promise} a promise you can use "then" to know when it is complete.
   */
  glideTo(pixelX, pixelY, milliseconds) {
    const _left = parseInt(this.htmldiv.style.left || "0px") || 0;
    const _top = parseInt(this.htmldiv.style.top || "0px") || 0;
    return animate((progress) => { 
      this.htmldiv.style.left = '' + (_left + progress * (pixelX-_left)) + 'px'; 
      this.htmldiv.style.top = '' + (_top + progress * (pixelY-_top)) + 'px'; }, milliseconds);
  }

  /**
   * setY
   * @param   {number} pixelY  
   */
  setY(pixelY) {
    this.htmldiv.style.top = '' + pixelY + 'px';
  }

  /**
   * setX
   * @param   {number} pixelX  
   */
  setX(pixelX) {
    this.htmldiv.style.left = '' + pixelX + 'px';
  }
  /**
   * getDiv
   * @returns {object} a reference to a &lt;div> tag in the DOM.
   */
  getDiv() {
    return this.htmldiv;
  }

}
/**
 * Controls helps move a div object on the page.
 */
class Controls {
  /**
   * Waits for some milliseconds, and calls the code in the "then" block.
   * @example
   * Controls.wait(1000).then(()=>{console.log("done");});
   * @param   {number} milliseconds  
   * @returns {Promise} a promise you can use "then" to know when it is complete.
   */
  static wait(milliseconds) {
    return new Promise((resolve, reject) => {
      setTimeout(() => { resolve() }, milliseconds);
    });
  }
  /**
   * Calls a given function, in a loop a number of times.
   * @example
   * let func=function(i,c){
   *    console.log(`loop ${i} of ${c}`);
   * };
   * Controls.repeate(func,4).then((i,c)=>{
   *    console.log("done");
   * });
   * @param   {function} func
   * @param   {number} count  
   * @param   {number} delay - [optional] defaults to 10ms
   * @returns {Promise} a promise you can use "then" to know when it is complete.
   */
  static repeat(func, count, delay) {
    let i = 0
    let _func = func;
    let _count = count;
    let _delay = delay || 10;
    return new Promise((resolve, reject) => {
      const loopCode = function () {
        _func(i, _count);
        i = i + 1;
        if (i &lt; _count) {
          setTimeout(loopCode, _delay);
        }
        else {
          resolve();
        }
      };
      loopCode();
    });
  }
}
/**
 * Backdrop helps manipulate a given background DIV
 * @example
 * const mainarea = new Sprite("#mainarea");
 * mainarea.addBackdrop("https://image.com");
 * mainarea.switchBackdropTo(0);
 *
 */
class Backdrop {
  /**
   * Create a Sprite object.
   * @param {object} htmldiv - The htmldiv object to move.
   */
  constructor(htmldiv) {
    if (htmldiv == null) {
      this.htmldiv = document.createElement("div");
      this.htmldiv.id = "backdrop";
    }
    else if (typeof htmldiv === "string") {
      this.htmldiv = document.querySelector(htmldiv);
    }
    else {
      this.htmldiv = htmldiv;
    }
    this.backdrops = [];
    this.bdindex=0;
    if (this.htmldiv.style.backgroundImage) {
      this.backdrops.push(this.htmldiv.style.backgroundImage.replace(/url\(('|")(.*)('|")\).*/, "$1"));
    }
    if (!this.htmldiv.style.textAlign) {
      this.htmldiv.style.textAlign = "left";
    }
  }
  /**
  * create 
  * @param   {image}
  * @param   {height}
  * @param   {width}
  * @returns {Sprite} a new Sprite.
  */
  static create({ image, backgroundColor, height, width }) {
    let backdrop = new Backdrop();
    if(image) backdrop.htmldiv.style.backgroundImage = `url('${image}')`;
    if(backgroundColor) backdrop.htmldiv.style.backgroundColor = `${backgroundColor}`;
    if(height) backdrop.htmldiv.style.height = `${height}px`;
    if(width) backdrop.htmldiv.style.width = `${width}px`;
    backdrop.htmldiv.style.overflow="hidden";
    backdrop.htmldiv.style.backgroundSize = "contain";
    backdrop.htmldiv.style.backgroundRepeat = "no-repeat";
    backdrop.htmldiv.style.backgroundPosition = "center";
    document.body.append(backdrop.htmldiv);
    return backdrop;
  }
  /**
 * Adds an image to the end of a list of backdrops.
 * @example
 * mainarea.addBackdrop("https://image.com");
 * @param   {string} imageURI  
 */
  addBackdrop(imageURI) {
    this.backdrops.push(imageURI);
  }
  /**
   * Adds an sprite to the end of a list of backdrop spites.
   * @example
   * mainarea.addBackdrop("https://image.com");
   * @param   {object} sprite  
   */
  addSprite(sprite) {
    this.htmldiv.append(sprite.getDiv());
  }
  /**
   * Switch backdrop to a specific index of a list of backdrops, starting at zero.
   * @example
   * mainarea.switchBackdropToIndex(0);
   * @param   {number} index  
   */
  switchBackdropToIndex(index) {
    if (index >= this.backdrops.length) return;
    this.htmldiv.style.backgroundImage = 'url("' + this.backdrops[index] + '")';
  }
  /**
   * Next backdrop to a specific index of a list of backdrops, starting at zero.
   * @example
   * mainarea.switchBackdropToIndex(0);
   * @param   {number} index  
   */
  nextBackdrop() {
    this.htmldiv.style.backgroundImage = 'url("' + this.backdrops[this.bdindex+1] + '")';
    this.bdindex=this.bdindex+1;
    if (this.bdindex >= this.backdrops.length) this.bdindex=0;
  }

  /**
   * Change the color  [TBC]
   * @example
   * mainarea.changeColor("red",0);
   * @param   {string} colour  
   * @param   {number} effectBy  
   */
  changeColor(color, effectBy) {

  }
  /**
 * Set the color  [TBC]
 * @example
 * mainarea.setColor("red");
 * @param   {string} color
 */
  setColor(color) {

  }
  /**
   * Clear the graphics effect [TBC]
   * @example
   * mainarea.clearGraphicsEffect();
   * @param   {string} color
   */
  clearGraphicsEffect() {

  }
}

</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Sat Sep 07 2024 13:25:11 GMT+0000 (Coordinated Universal Time) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
